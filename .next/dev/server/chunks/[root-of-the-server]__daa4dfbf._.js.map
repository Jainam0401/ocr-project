{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/ASUS/Desktop/ocr-project/app/api/extract-text/route.ts"],"sourcesContent":["export const runtime = \"nodejs\";\r\n\r\nimport { NextRequest, NextResponse } from \"next/server\";\r\nimport fs from \"fs/promises\";\r\nimport path from \"path\";\r\nimport { exec } from \"child_process\";\r\nimport util from \"util\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport tesseract from \"node-tesseract-ocr\";\r\nimport pLimit from \"p-limit\";\r\n\r\nexport const maxDuration = 300;\r\nexport const dynamic = \"force-dynamic\";\r\n\r\nconst execAsync = util.promisify(exec);\r\n\r\nexport async function POST(req: NextRequest) {\r\n  let tempDir: string | null = null;\r\n  let pdfPath: string | null = null;\r\n  const startTime = Date.now();\r\n\r\n  try {\r\n    const formData = await req.formData();\r\n    const file = formData.get(\"file\") as File;\r\n    const language = (formData.get(\"language\") as string) || \"eng\";\r\n\r\n    if (!file) {\r\n      return NextResponse.json({ success: false, error: \"No file uploaded\" }, { status: 400 });\r\n    }\r\n\r\n    if (!file.name.toLowerCase().endsWith(\".pdf\")) {\r\n      return NextResponse.json({ success: false, error: \"Only PDF files are supported\" }, { status: 400 });\r\n    }\r\n\r\n    // Temporary directory\r\n    const uniqueId = uuidv4();\r\n    tempDir = path.join(process.cwd(), \"temp\", uniqueId);\r\n    await fs.mkdir(tempDir, { recursive: true });\r\n\r\n    const arrayBuffer = await file.arrayBuffer();\r\n    const buffer = Buffer.from(arrayBuffer);\r\n    pdfPath = path.join(tempDir, `${uniqueId}.pdf`);\r\n    await fs.writeFile(pdfPath, buffer);\r\n\r\n    console.log(`Uploaded: ${file.name} (${(buffer.length / 1024).toFixed(2)} KB)`);\r\n\r\n    const pdfLib = await import(\"pdf-lib\");\r\n    const pdfDoc = await pdfLib.PDFDocument.load(buffer);\r\n    const totalPages = pdfDoc.getPageCount();\r\n    console.log(`Total pages: ${totalPages}`);\r\n\r\n    console.log(\"Converting PDF to images...\");\r\n    await execAsync(`pdftoppm \"${pdfPath}\" \"${path.join(tempDir, \"page\")}\" -png -r 200`);\r\n    console.log(\"Conversion done\");\r\n\r\n    const config = { lang: language, oem: 1, psm: 3 };\r\n    const limit = pLimit(3);\r\n    const ocrTasks: Promise<string>[] = [];\r\n\r\n    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {\r\n      const imagePath = path.join(tempDir, `page-${pageNum}.png`);\r\n\r\n      ocrTasks.push(\r\n        limit(async () => {\r\n          console.log(`Running OCR on page ${pageNum}/${totalPages}`);\r\n          try {\r\n            const text = await tesseract.recognize(imagePath, config);\r\n            return `\\n\\n--- Page ${pageNum} ---\\n${text}`;\r\n          } catch (err: any) {\r\n            console.error(`OCR failed on page ${pageNum}: ${err.message}`);\r\n            return `\\n\\n--- Page ${pageNum} ---\\n[Error: ${err.message}]`;\r\n          }\r\n        })\r\n      );\r\n    }\r\n\r\n    const results = await Promise.allSettled(ocrTasks);\r\n    const extractedText = results\r\n      .map((r, i) => (r.status === \"fulfilled\" ? r.value : `--- Page ${i + 1} --- [Error]`))\r\n      .join(\"\\n\");\r\n\r\n    const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);\r\n    console.log(`OCR completed in ${totalTime}s`);\r\n     if (tempDir) {\r\n      (async () => {\r\n        try {\r\n          await fs.rm(tempDir, { recursive: true, force: true });\r\n          console.log(`Temporary folder deleted: ${tempDir}`);\r\n        } catch (cleanupError: any) {\r\n          console.error(\"Cleanup error:\", cleanupError.message);\r\n        }\r\n      })();\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      text: extractedText.trim(),\r\n      metadata: {\r\n        fileName: file.name,\r\n        fileSize: `${(buffer.length / 1024).toFixed(2)} KB`,\r\n        totalPages,\r\n        language,\r\n        processingTime: `${totalTime}s`,\r\n        concurrency: 3,\r\n        dpi: 200,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error(\"Error processing PDF:\", error);\r\n    return NextResponse.json(\r\n      { success: false, error: error.message || \"Failed to process PDF\" },\r\n      { status: 500 }\r\n    );\r\n  } finally {\r\n    if (tempDir) {\r\n      await fs.rm(tempDir, { recursive: true, force: true }).catch((e) =>\r\n        console.error(\"Cleanup error:\", e.message)\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport async function GET() {\r\n  return NextResponse.json({\r\n    status: \"healthy\",\r\n    endpoint: \"/api/extract-text\",\r\n    methods: [\"POST\"],\r\n    description: \"PDF to text OCR extraction API\",\r\n  });\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}